<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Recursive fibonacci with memoization | WZRD</title>
    <meta name="description" content="" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="/favicon.ico">
    <link  rel="stylesheet" href="/css/screen.css" /><link  rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /><link  rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/solarized-dark.min.css" />
    
  </head>
  <body class="post-template nav-closed">
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
      <span class="hidden">Close</span>
    </a>
    <ul>
      
        <li class="nav-any" role="presentation">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-any" role="presentation">
          <a href="/about/">About</a>
        </li>
      
        <li class="nav-any" role="presentation">
          <a href="/tags/programming/">Programming</a>
        </li>
      
    </ul>
    
</div>
<span class="nav-cover"></span>
    <div class="site-wrapper">

      <header class="main-header post-head" style="background-image: url(/img/Entrepierres_Sisteron_France-Noah_Basle.jpg)">
  <nav class="main-nav overlay clearfix">
    
    
      <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
    
  </nav>
</header>

<main class="content" role="main">
  <article class="post">

    <header class="post-header">
      <h1 class="post-title">Recursive fibonacci with memoization</h1>
      <section class="post-meta">
        
        <time class="post-date" datetime="2016-March-06">06 March 2016</time> 
    <a href="/tags/programming/">programming</a>

      </section>
    </header>
    
    <section class="post-content">
      <p>Recursive functions can be used for when you have one big problem and want to split it up into many smaller problems or &quot;divide and conquer&quot; as it is commonly refered to.</p>
<p>The fibonacci sequence is a popular example to use in recursive functions since the function calls mirrors the actual formula<sup><a href="#1">[1]</a></sup>. Below we have implemented a simple recursive function in golang.</p>
<pre class="highlight"><code class="hljs go"><span class="hljs-keyword">func</span> fib_rec(number <span class="hljs-typename">int</span>) <span class="hljs-typename">int</span> {
    <span class="hljs-keyword">if</span> number &lt;<span class="hljs-number"> 2</span> {
        <span class="hljs-keyword">return</span> number;
    }
    <span class="hljs-keyword">return</span> fib_rec(number<span class="hljs-number">-2</span>) + fib_rec(number<span class="hljs-number">-1</span>)
}
<span class="hljs-comment">// Example 1 - Recursive fibonacci</span>
</code></pre>
<p>However in practice this could be considered an inefficient solution which leads to an unecessary amount of function calls since each function call for N&gt;2 will spawn two more function calls. One way of solving this is by the use of memoization<sup><a href="#2">[2]</a></sup>. Memoization an optimization technique more commonly known in functional programming languages but that doesn&#39;t mean we can&#39;t use it here. What it essentialy means is we&#39;re saving the output of any function call in memory and use that saved output instead of the function call for any repeated calls with the same input.</p>
<pre class="highlight"><code class="hljs go"><span class="hljs-keyword">var</span> cache [N<span class="hljs-number">+1</span>]<span class="hljs-typename">int</span>

<span class="hljs-keyword">func</span> fib_mem(number <span class="hljs-typename">int</span>) <span class="hljs-typename">int</span> {
    <span class="hljs-keyword">if</span> number &lt;<span class="hljs-number"> 2</span> {
        <span class="hljs-keyword">return</span> number;
    }
    <span class="hljs-keyword">if</span> cache[number] ==<span class="hljs-number"> 0</span> { <span class="hljs-comment">// Save to cache if not set</span>
        cache[number] = fib_mem(number<span class="hljs-number">-2</span>) + fib_mem(number<span class="hljs-number">-1</span>)
    }
    <span class="hljs-keyword">return</span> cache[number]
}
<span class="hljs-comment">// Example 2 - Recursive fibonacci with memoization</span>
</code></pre>
<p>To visualize this I&#39;ve made a tree where the number is the input parameter of a function call</p>
<pre class="highlight"><code class="hljs no-highlight"> With memoization |      Without memoization
------------------+---------------------------------
                  |           __ 6 __
                  |         /         \
          6       |        4         _ 5 _
         / \      |       / \       /     \
        4   5     |      2   3     3       4
       / \        |     /   / \   / \     / \
      2   3       |    1   1   2 1   2   2   3
     /   /        |           /     /   /   / \
    1   1         |          1     1   1   1   2
                  |                           /
                  |                          1
</code></pre>
<p>As you may note F(1) is actually called twice, once from F(2) and once for F(3). This can easily be avoided by storing cache[1]=1 before starting the recursion and instead only return number if number==0 but even if we don&#39;t F(1) will only be called twice no matter how big N we&#39;re using, this because any subsequent calls to F(4) will just look up the memoized the output of F(4) instead of traversing further down the tree.
Even if this reduction of function calls does not look huge, what we&#39;re really doing is reducing the complexity from O(2<sup>n</sup>)<sup><a href="#3">[3]</a></sup> to O(n) the benefit of which becomes more appearant the higher N, for each higher number of N we essentially need to copy the biggest branch of the existing tree and run through it all again, with memoization we&#39;re storing the result of each branch in that tree and use that cache to avoid function calls when the result is known from a previous calculation. If N was 50 we&#39;re talking many billions of function calls compared to 50.</p>
<h2 id="other-solutions">Other solutions</h2>
<p>As a sidenote it can be worth noting that using a standard iterative function can be considered just as fast and easier to understand. The Nth fibonacci can also more efficiently be solved by using various mathematical techniques: matrix exponetiation, fast doubling, or rounding but I consider that out of scope for this post.</p>
<pre class="highlight"><code class="hljs go"><span class="hljs-keyword">func</span> fib_iter(number <span class="hljs-typename">int</span>) <span class="hljs-typename">int</span> {
    first, second :=<span class="hljs-number"> 0</span>,<span class="hljs-number"> 1</span>
    <span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; number; i++ {
        first, second = second, first+second
    }
    <span class="hljs-keyword">return</span> first
}
<span class="hljs-comment">// Example 3 - Iterative fibonacci</span>
</code></pre>
<h4 id="footnotes">Footnotes</h4>
<ul>
<li><a name="1">[1]</a>: F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>, with seed values F<sub>0</sub> = 0, F<sub>1</sub> = 1</li>
<li><a name="2">[2]</a>: Note the spelling memoization, not to be confused with memorization</li>
<li><a name="3">[3]</a>: Closer to O(φ<sup>n</sup>) where φ is the golden ratio≈1.618, but that&#39;s not significantly relevant here</li>
</ul>
<!---
* <a name="4">[4]</a>: Fibonacci matrix exponentiation: 
    $$\left[ \begin{matrix} 1 && 1 \\\\ 1 && 0 \end{matrix} \right]^n = \left[ \begin{matrix} F(n+1) && F(n) \\\\ F(n) && F(n-1) \end{matrix} \right]$$
* <a name="5">[5]</a>: Fibonacci fast doubling:
$$\begin{align}
  F(2k) &= F(k) \left[ 2F(k+1) - F(k) \right]. \\\\
  F(2k+1) &= F(k+1)^2 + F(k)^2.
\end{align}$$
* <a name="6">[6]</a>: Fibonacci rounding (rounded to closest integer): 
    $$F_n=\bigg[\frac{\phi^n}{\sqrt 5}\bigg]$$

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
-->
    </section>
    
    <footer class="post-footer">

      

      
      

    </footer>

  </article>
</main>

<aside class="read-next">
  
    
      
      
    
  
</aside>

      <footer class="site-footer clearfix">
        <section class="copyright"><a href="http://wzrd.se">WZRD</a> &copy; 2017</section>
      </footer>

    </div>
    <script defer="defer"  src="//code.jquery.com/jquery-2.1.4.min.js"></script><script defer="defer"  src="/js/jquery.fitvids.js"></script><script defer="defer"  src="/js/index.js"></script>
    
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-74672759-1', 'auto');
    ga('send', 'pageview');
  </script>


    
<script>
var _rollbarConfig = {
    accessToken: "9796a6b580b64acca6e28c238e0531c8",
    captureUncaught: true,
    payload: {
        environment: "test"
    }
};
!function(r){function o(e){if(t[e])return t[e].exports;var n=t[e]={exports:{},id:e,loaded:!1};return r[e].call(n.exports,n,n.exports,o),n.loaded=!0,n.exports}var t={};return o.m=r,o.c=t,o.p="",o(0)}([function(r,o,t){"use strict";var e=t(1).Rollbar,n=t(2);_rollbarConfig.rollbarJsUrl=_rollbarConfig.rollbarJsUrl||"https://d37gvrvc0wt4s1.cloudfront.net/js/v1.8/rollbar.min.js";var a=e.init(window,_rollbarConfig),i=n(a,_rollbarConfig);a.loadFull(window,document,!_rollbarConfig.async,_rollbarConfig,i)},function(r,o){"use strict";function t(r){return function(){try{return r.apply(this,arguments)}catch(o){try{console.error("[Rollbar]: Internal error",o)}catch(t){}}}}function e(r,o,t){window._rollbarWrappedError&&(t[4]||(t[4]=window._rollbarWrappedError),t[5]||(t[5]=window._rollbarWrappedError._rollbarContext),window._rollbarWrappedError=null),r.uncaughtError.apply(r,t),o&&o.apply(window,t)}function n(r){var o=function(){var o=Array.prototype.slice.call(arguments,0);e(r,r._rollbarOldOnError,o)};return o.belongsToShim=!0,o}function a(r){this.shimId=++s,this.notifier=null,this.parentShim=r,this._rollbarOldOnError=null}function i(r){var o=a;return t(function(){if(this.notifier)return this.notifier[r].apply(this.notifier,arguments);var t=this,e="scope"===r;e&&(t=new o(this));var n=Array.prototype.slice.call(arguments,0),a={shim:t,method:r,args:n,ts:new Date};return window._rollbarShimQueue.push(a),e?t:void 0})}function l(r,o){if(o.hasOwnProperty&&o.hasOwnProperty("addEventListener")){var t=o.addEventListener;o.addEventListener=function(o,e,n){t.call(this,o,r.wrap(e),n)};var e=o.removeEventListener;o.removeEventListener=function(r,o,t){e.call(this,r,o&&o._wrapped?o._wrapped:o,t)}}}var s=0;a.init=function(r,o){var e=o.globalAlias||"Rollbar";if("object"==typeof r[e])return r[e];r._rollbarShimQueue=[],r._rollbarWrappedError=null,o=o||{};var i=new a;return t(function(){if(i.configure(o),o.captureUncaught){i._rollbarOldOnError=r.onerror,r.onerror=n(i);var t,a,s="EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(",");for(t=0;t<s.length;++t)a=s[t],r[a]&&r[a].prototype&&l(i,r[a].prototype)}return r[e]=i,i})()},a.prototype.loadFull=function(r,o,e,n,a){var i=function(){var o;if(void 0===r._rollbarPayloadQueue){var t,e,n,i;for(o=new Error("rollbar.js did not load");t=r._rollbarShimQueue.shift();)for(n=t.args,i=0;i<n.length;++i)if(e=n[i],"function"==typeof e){e(o);break}}"function"==typeof a&&a(o)},l=!1,s=o.createElement("script"),u=o.getElementsByTagName("script")[0],p=u.parentNode;s.crossOrigin="",s.src=n.rollbarJsUrl,s.async=!e,s.onload=s.onreadystatechange=t(function(){if(!(l||this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState)){s.onload=s.onreadystatechange=null;try{p.removeChild(s)}catch(r){}l=!0,i()}}),p.insertBefore(s,u)},a.prototype.wrap=function(r,o){try{var t;if(t="function"==typeof o?o:function(){return o||{}},"function"!=typeof r)return r;if(r._isWrap)return r;if(!r._wrapped){r._wrapped=function(){try{return r.apply(this,arguments)}catch(o){throw o._rollbarContext=t()||{},o._rollbarContext._wrappedSource=r.toString(),window._rollbarWrappedError=o,o}},r._wrapped._isWrap=!0;for(var e in r)r.hasOwnProperty(e)&&(r._wrapped[e]=r[e])}return r._wrapped}catch(n){return r}};for(var u="log,debug,info,warn,warning,error,critical,global,configure,scope,uncaughtError".split(","),p=0;p<u.length;++p)a.prototype[u[p]]=i(u[p]);r.exports={Rollbar:a,_rollbarWindowOnError:e}},function(r,o){"use strict";r.exports=function(r,o){return function(t){if(!t&&!window._rollbarInitialized){var e=window.RollbarNotifier,n=o||{},a=n.globalAlias||"Rollbar",i=window.Rollbar.init(n,r);i._processShimQueue(window._rollbarShimQueue||[]),window[a]=i,window._rollbarInitialized=!0,e.processPayloads()}}}}]);
</script>


  </body>
</html>